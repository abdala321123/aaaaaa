// File: netlify/functions/crypto.js
const cache = require("@netlify/cache-utils");

// Konfiguration
const CACHE_DURATION_MS = 24 * 60 * 60 * 1000; // 24 Stunden

// Holen Sie den API-Schlüssel sicher aus den Netlify-Umgebungsvariablen
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// Alle API-Endpunkte und Hilfsfunktionen von früher sind jetzt hier auf dem Server
const API_ENDPOINTS = {
    DCT: 'https://dctapp.de/whatstomine.php',
    COINGECKO_SEARCH: 'https://api.coingecko.com/api/v3/search',
    COINGECKO_PRICE: 'https://api.coingecko.com/api/v3/simple/price',
    COINGECKO_DETAILED: 'https://api.coingecko.com/api/v3/coins',
    BLOCKCHAIR: 'https://api.blockchair.com',
    CRYPTOCOMPARE_DATA: 'https://min-api.cryptocompare.com/data/blockchain/mining/calculator',
    CRYPTOCOMPARE_PRICE: 'https://min-api.cryptocompare.com/data/pricemultifull',
    BINANCE_PRICE: 'https://api.binance.com/api/v3/ticker/24hr',
    COINBASE_PRICE: 'https://api.coinbase.com/v2/exchange-rates',
    GEMINI: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent'
};

const blockchairChainMap = {
    'BTC': 'bitcoin', 'BCH': 'bitcoin-cash', 'LTC': 'litecoin', 'DOGE': 'dogecoin', 
    'DASH': 'dash', 'ZEC': 'zcash', 'XMR': 'monero', 'BSV': 'bitcoin-sv', 
    'GRS': 'groestlcoin', 'PPC': 'peercoin', 'XEC': 'ecash', 'ETC': 'ethereum-classic',
    'ETH': 'ethereum'
};

// Hauptfunktion, die von Netlify aufgerufen wird
exports.handler = async (event, context) => {
    // CORS-Header: Erlaubt Anfragen von jeder Domain (wichtig für Shopify)
    const headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Content-Type': 'application/json'
    };
    
    // Preflight-Anfragen für CORS handhaben
    if (event.httpMethod === 'OPTIONS') {
        return {
            statusCode: 204,
            headers
        };
    }

    const coinSymbol = event.queryStringParameters.coin;
    if (!coinSymbol) {
        return {
            statusCode: 400,
            headers,
            body: JSON.stringify({ error: 'Coin symbol query parameter is required.' })
        };
    }
    
    const cacheKey = `crypto-data-${coinSymbol.toUpperCase()}`;

    // 1. Cache prüfen
    if (await cache.has(cacheKey)) {
        const { mtimeMs } = await cache.getStat(cacheKey);
        const age = Date.now() - mtimeMs;
        if (age < CACHE_DURATION_MS) {
            console.log(`Cache HIT for ${coinSymbol}`);
            const cachedData = await cache.get(cacheKey);
            return {
                statusCode: 200,
                headers,
                body: cachedData.toString()
            };
        }
    }
    
    console.log(`Cache MISS for ${coinSymbol}. Fetching fresh data...`);

    // 2. Wenn Cache leer oder veraltet: Daten frisch abrufen
    try {
        const identifiedCoin = await identifyCoin(coinSymbol);
        if (!identifiedCoin) throw new Error(`Could not identify ${coinSymbol}`);

        const [priceData, blockchairData, cryptoCompareData, dctData, geckoDetailed] = await Promise.all([
            safeFetch(fetchEnhancedPrice(identifiedCoin)),
            safeFetch(fetchBlockchairStats(identifiedCoin)),
            safeFetch(fetchCryptoCompareData(identifiedCoin.symbol.toUpperCase())),
            safeFetch(getValidNetworkDataFromDct(identifiedCoin)),
            safeFetch(fetchCoinGeckoDetailed(identifiedCoin))
        ]);

        let finalData = mergeDataSources(identifiedCoin, priceData, blockchairData, cryptoCompareData, dctData, geckoDetailed);
        finalData = await fillMissingValuesWithGemini(finalData);

        if (!isDataSufficient(finalData)) {
            throw new Error(`Data collected for ${coinSymbol} was insufficient.`);
        }

        // 3. Erfolgreiche Daten im Cache speichern
        const dataToCache = JSON.stringify(finalData);
        await cache.set(cacheKey, Buffer.from(dataToCache));

        return {
            statusCode: 200,
            headers,
            body: dataToCache
        };

    } catch (error) {
        console.error(`Error fetching data for ${coinSymbol}:`, error);
        return {
            statusCode: 500,
            headers,
            body: JSON.stringify({ error: error.message })
        };
    }
};

// --- Alle Hilfsfunktionen von früher sind jetzt hier ---

async function safeFetch(promise) { try { return await promise; } catch (error) { console.warn(`A fetch op failed: ${error.message}`); return null; } }
function isDataSufficient(data) { if (!data) return false; return !!(data.id && data.name && data.tag && data.price > 0 && (data.nethash > 0 || data.difficulty > 0)); }
async function identifyCoin(query) { /* ...komplette identifyCoin Funktion von vorher... */ }
function mergeDataSources(coin, price, blockchair, cryptocompare, dct, geckoDetailed) { /* ...komplette mergeDataSources Funktion von vorher... */ }
async function fillMissingValuesWithGemini(data) { /* ...komplette fillMissingValuesWithGemini Funktion von vorher... */ }
async function callGeminiAPI(prompt) { /* ...komplette callGeminiAPI Funktion von vorher... */ }
async function findCoinOnCoinGecko(query) { /* ...etc... */ }
// ... und so weiter für ALLE anderen Hilfsfunktionen (fetchEnhancedPrice, fetchCoinGeckoPrice, etc.)
// Kopieren Sie einfach den gesamten Block der Hilfsfunktionen aus dem vorherigen Code hierher.
// Stellen Sie sicher, dass sie außerhalb der 'handler' Funktion, aber in derselben Datei sind.

// Beispielhaft hier einige der Funktionen reinkopiert, Sie müssen ALLE einfügen:
async function identifyCoin(query) {
    let coinInfo = await safeFetch(findCoinOnCoinGecko(query));
    if (coinInfo) return coinInfo;
    const dctResult = await safeFetch(fetchNetworkDataFromBackend(query));
    if (dctResult && !dctResult.error && dctResult.tag) {
        coinInfo = await safeFetch(findCoinOnCoinGecko(dctResult.tag));
        if (coinInfo) return coinInfo;
        return { id: dctResult.tag.toLowerCase(), symbol: dctResult.tag, name: dctResult.name || query };
    }
    const geminiSymbol = await safeFetch(callGeminiAPI(`What is the official coin symbol for a cryptocurrency called "${query}"? Respond with the symbol only, e.g., "BTC".`));
    if (geminiSymbol) return await safeFetch(findCoinOnCoinGecko(geminiSymbol.trim()));
    return null;
}
async function findCoinOnCoinGecko(query) { 
    const url = `${API_ENDPOINTS.COINGECKO_SEARCH}?query=${encodeURIComponent(query)}`;
    const response = await fetch(url);
    if (!response.ok) throw new Error(`CoinGecko search failed: ${response.statusText}`);
    const data = await response.json();
    if (!data.coins || data.coins.length === 0) return null;
    const lowerQuery = query.toLowerCase();
    const bestMatch = data.coins.find(c => c.symbol.toLowerCase() === lowerQuery) || data.coins.find(c => c.name.toLowerCase() === lowerQuery) || data.coins[0];
    return { id: bestMatch.id, symbol: bestMatch.symbol, name: bestMatch.name };
}
// ... FÜGEN SIE HIER ALLE WEITEREN HELFERFUNKTIONEN EIN ...