// FINAL BACKEND CODE for netlify/functions/crypto.js
// This version uses Minerstat as the primary, reliable data source and CoinGecko for live prices.

const API_ENDPOINTS = {
    MINERSTAT_COINS: 'https://api.minerstat.com/v2/coins',
    COINGECKO_SEARCH: 'https://api.coingecko.com/api/v3/search',
    COINGECKO_PRICE: 'https://api.coingecko.com/api/v3/simple/price',
};

// Simple in-memory cache for the Minerstat DB to reduce API calls to Minerstat
let minerstatDatabase = null;
let dbTimestamp = 0;
const DB_CACHE_DURATION_MS = 60 * 60 * 1000; // Cache DB for 1 hour

// This helper function gets the entire coin database from Minerstat
// and caches it in memory to avoid fetching it for every single coin request.
async function getMinerstatData() {
    if (minerstatDatabase && (Date.now() - dbTimestamp < DB_CACHE_DURATION_MS)) {
        console.log("Using in-memory cached Minerstat DB.");
        return minerstatDatabase;
    }
    console.log("Fetching fresh Minerstat DB.");
    // We don't need a proxy here because this is a server-to-server request.
    const response = await fetch(API_ENDPOINTS.MINERSTAT_COINS);
    if (!response.ok) throw new Error("Could not fetch Minerstat database");
    
    const data = await response.json();
    
    // Convert the array into an object keyed by the coin symbol for fast lookups
    const db = data.reduce((acc, coin) => {
        acc[coin.coin] = coin;
        return acc;
    }, {});

    minerstatDatabase = db;
    dbTimestamp = Date.now();
    return db;
}

// This is the main function that runs when your proxy URL is called
exports.handler = async (event) => {
    // Standard headers to allow the request from your Shopify store
    const headers = { 
        'Access-Control-Allow-Origin': '*', 
        'Content-Type': 'application/json' 
    };
    if (event.httpMethod === 'OPTIONS') {
        return { statusCode: 204, headers };
    }

    const coinSymbol = event.queryStringParameters.coin;
    if (!coinSymbol) {
        return { statusCode: 400, headers, body: JSON.stringify({ error: 'Coin symbol is required.' }) };
    }

    try {
        // 1. Get reliable network data from Minerstat's database
        const db = await getMinerstatData();
        const minerstatData = db[coinSymbol.toUpperCase()];
        if (!minerstatData) throw new Error(`Coin ${coinSymbol} not found in Minerstat DB.`);

        // 2. Get live price data from CoinGecko using the coin's name for a reliable match
        const searchResponse = await fetch(`${API_ENDPOINTS.COINGECKO_SEARCH}?query=${encodeURIComponent(minerstatData.name)}`);
        if (!searchResponse.ok) throw new Error('CoinGecko search failed.');
        const searchData = await searchResponse.json();
        const coinInfo = searchData.coins?.[0]; // Take the best match
        if (!coinInfo) throw new Error(`Coin ${coinSymbol} not found on CoinGecko.`);

        const priceResponse = await fetch(`${API_ENDPOINTS.COINGECKO_PRICE}?ids=${coinInfo.id}&vs_currencies=usd&include_24hr_change=true`);
        if (!priceResponse.ok) throw new Error('CoinGecko price fetch failed.');
        const priceData = await priceResponse.json();
        const liveData = priceData[coinInfo.id];
        if (!liveData) throw new Error('Could not retrieve live price data.');

        // 3. Assemble the final, high-quality data object to send back to the frontend
        const finalData = {
            name: minerstatData.name,
            tag: minerstatData.coin,
            coingeckoId: coinInfo.id,
            price: liveData.usd,
            priceChange24h: liveData.usd_24h_change,
            nethash: parseFloat(minerstatData.network_hashrate),
            blockReward: parseFloat(minerstatData.reward),
            blockTime: parseFloat(minerstatData.reward_block_time)
        };

        return { statusCode: 200, headers, body: JSON.stringify(finalData) };

    } catch (error) {
        console.error(`Error processing ${coinSymbol}:`, error);
        return { statusCode: 500, headers, body: JSON.stringify({ error: error.message }) };
    }
};
